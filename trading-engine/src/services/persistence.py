"""
Persistence service for trading cycle results.

Records all cycle inputs/outputs to the events table for audit trail.
This ensures every decision made by the system is traceable.

Events recorded:
- CycleStarted: When a trading cycle begins
- SignalGenerated: Each signal from DataAgent
- RiskAssessed: Each risk assessment from RiskManager
- ValidationComplete: Each validation from Validator
- MetaAgentDecision: Each final decision from MetaAgent
- CycleCompleted: When a trading cycle ends (with summary)
"""

from datetime import datetime
from typing import Any
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.database.models import Event, EventType
from src.utils.logging import get_logger
from src.workflows.state import (
    FinalDecision,
    RiskAssessment,
    Signal,
    TradingState,
    Validation,
)

log = get_logger(__name__)


class CyclePersistenceService:
    """
    Persists trading cycle data to the events table.

    All events are append-only for complete audit trail.
    Uses the cycle_id as aggregate_id to group related events.
    """

    def __init__(self, db_session: AsyncSession):
        """
        Initialize the persistence service.

        Args:
            db_session: Async SQLAlchemy session for database operations
        """
        self.db = db_session

    async def record_cycle_started(
        self,
        cycle_id: UUID,
        cycle_type: str,
        symbols: list[str],
        trigger_symbol: str | None = None,
    ) -> None:
        """
        Record the start of a trading cycle.

        Args:
            cycle_id: Unique identifier for this cycle
            cycle_type: "scheduled" or "event"
            symbols: Symbols being analyzed
            trigger_symbol: For event cycles, the triggering symbol
        """
        event = Event(
            event_type="CycleStarted",
            aggregate_id=str(cycle_id),
            data={
                "cycle_type": cycle_type,
                "symbols": symbols,
                "trigger_symbol": trigger_symbol,
            },
            event_metadata={
                "version": "1.0",
            },
        )
        self.db.add(event)
        await self.db.flush()

        log.info(
            "cycle_started_recorded",
            cycle_id=str(cycle_id),
            cycle_type=cycle_type,
            symbol_count=len(symbols),
        )

    async def record_signals(
        self,
        cycle_id: UUID,
        signals: list[Signal],
    ) -> None:
        """
        Record all signals generated by DataAgent.

        Args:
            cycle_id: Cycle identifier
            signals: List of signals to record
        """
        for signal in signals:
            event = Event(
                event_type=EventType.SIGNAL_GENERATED.value,
                aggregate_id=str(cycle_id),
                data={
                    "signal_id": str(signal.id),
                    "symbol": signal.symbol,
                    "action": signal.action.value,
                    "confidence": signal.confidence,
                    "proposed_quantity": signal.proposed_quantity,
                    "reasoning": signal.reasoning,
                    "price": signal.price,
                    "rsi_14": signal.rsi_14,
                    "sma_20": signal.sma_20,
                    "sma_50": signal.sma_50,
                    "sma_200": signal.sma_200,
                    "volume_ratio": signal.volume_ratio,
                },
                event_metadata={
                    "agent": "DataAgent",
                },
            )
            self.db.add(event)

        await self.db.flush()

        log.debug(
            "signals_recorded",
            cycle_id=str(cycle_id),
            count=len(signals),
        )

    async def record_risk_assessments(
        self,
        cycle_id: UUID,
        assessments: list[RiskAssessment],
    ) -> None:
        """
        Record all risk assessments from RiskManager.

        Args:
            cycle_id: Cycle identifier
            assessments: List of assessments to record
        """
        for assessment in assessments:
            event = Event(
                event_type=EventType.RISK_ASSESSED.value,
                aggregate_id=str(cycle_id),
                data={
                    "signal_id": str(assessment.signal_id),
                    "approved": assessment.approved,
                    "adjusted_quantity": assessment.adjusted_quantity,
                    "risk_score": assessment.risk_score,
                    "hard_constraint_violated": assessment.hard_constraint_violated,
                    "hard_constraint_reason": assessment.hard_constraint_reason,
                    "concerns": assessment.concerns,
                    "reasoning": assessment.reasoning,
                },
                event_metadata={
                    "agent": "RiskManager",
                },
            )
            self.db.add(event)

        await self.db.flush()

        log.debug(
            "risk_assessments_recorded",
            cycle_id=str(cycle_id),
            count=len(assessments),
            approved=len([a for a in assessments if a.approved]),
        )

    async def record_validations(
        self,
        cycle_id: UUID,
        validations: list[Validation],
    ) -> None:
        """
        Record all validations from Validator.

        Args:
            cycle_id: Cycle identifier
            validations: List of validations to record
        """
        for validation in validations:
            event = Event(
                event_type=EventType.VALIDATION_COMPLETE.value,
                aggregate_id=str(cycle_id),
                data={
                    "signal_id": str(validation.signal_id),
                    "approved": validation.approved,
                    "concerns": validation.concerns,
                    "suggestions": validation.suggestions,
                    "reasoning": validation.reasoning,
                    "repetition_detected": validation.repetition_detected,
                    "sector_clustering_detected": validation.sector_clustering_detected,
                    "similar_setup_failures": validation.similar_setup_failures,
                },
                event_metadata={
                    "agent": "Validator",
                },
            )
            self.db.add(event)

        await self.db.flush()

        log.debug(
            "validations_recorded",
            cycle_id=str(cycle_id),
            count=len(validations),
            approved=len([v for v in validations if v.approved]),
        )

    async def record_final_decisions(
        self,
        cycle_id: UUID,
        decisions: list[FinalDecision],
    ) -> None:
        """
        Record all final decisions from MetaAgent.

        Args:
            cycle_id: Cycle identifier
            decisions: List of decisions to record
        """
        for decision in decisions:
            event = Event(
                event_type=EventType.META_AGENT_DECISION.value,
                aggregate_id=str(cycle_id),
                data={
                    "signal_id": str(decision.signal_id),
                    "decision": decision.decision.value,
                    "final_quantity": decision.final_quantity,
                    "confidence": decision.confidence,
                    "reasoning": decision.reasoning,
                },
                event_metadata={
                    "agent": "MetaAgent",
                },
            )
            self.db.add(event)

        await self.db.flush()

        execute_count = len([d for d in decisions if d.decision.value == "EXECUTE"])
        log.debug(
            "final_decisions_recorded",
            cycle_id=str(cycle_id),
            count=len(decisions),
            execute=execute_count,
        )

    async def record_cycle_completed(
        self,
        state: TradingState,
        duration_seconds: float,
    ) -> None:
        """
        Record the completion of a trading cycle with summary.

        Args:
            state: Final trading state with all outputs
            duration_seconds: How long the cycle took
        """
        execute_decisions = state.get_execute_decisions()

        event = Event(
            event_type="CycleCompleted",
            aggregate_id=str(state.cycle_id),
            data={
                "cycle_type": state.cycle_type,
                "symbols": state.symbols,
                "duration_seconds": duration_seconds,
                "summary": {
                    "total_signals": len(state.signals),
                    "risk_approved": len([ra for ra in state.risk_assessments if ra.approved]),
                    "risk_rejected": len([ra for ra in state.risk_assessments if not ra.approved]),
                    "validated": len([v for v in state.validations if v.approved]),
                    "execute_decisions": len(execute_decisions),
                    "error_count": len(state.errors),
                },
                "errors": state.errors,
            },
            event_metadata={
                "version": "1.0",
            },
        )
        self.db.add(event)
        await self.db.flush()

        log.info(
            "cycle_completed_recorded",
            cycle_id=str(state.cycle_id),
            duration_seconds=round(duration_seconds, 2),
            signals=len(state.signals),
            execute_decisions=len(execute_decisions),
        )

    async def record_full_cycle(
        self,
        state: TradingState,
        duration_seconds: float,
    ) -> None:
        """
        Record all events for a completed trading cycle.

        Convenience method that records all cycle data in one call.

        Args:
            state: Complete trading state with all outputs
            duration_seconds: How long the cycle took
        """
        # Record start
        await self.record_cycle_started(
            cycle_id=state.cycle_id,
            cycle_type=state.cycle_type,
            symbols=state.symbols,
            trigger_symbol=state.trigger_symbol,
        )

        # Record agent outputs
        if state.signals:
            await self.record_signals(state.cycle_id, state.signals)

        if state.risk_assessments:
            await self.record_risk_assessments(state.cycle_id, state.risk_assessments)

        if state.validations:
            await self.record_validations(state.cycle_id, state.validations)

        if state.final_decisions:
            await self.record_final_decisions(state.cycle_id, state.final_decisions)

        # Record completion
        await self.record_cycle_completed(state, duration_seconds)

        # Commit all events
        await self.db.commit()

        log.info(
            "full_cycle_persisted",
            cycle_id=str(state.cycle_id),
            event_count=(
                1  # CycleStarted
                + len(state.signals)
                + len(state.risk_assessments)
                + len(state.validations)
                + len(state.final_decisions)
                + 1  # CycleCompleted
            ),
        )
